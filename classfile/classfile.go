package classfile

import (
	"github.com/pkg/errors"
)

type ClassFile struct {
	MinorVersion uint16
	MajorVersion uint16
	ConstantPool []CpInfo
	AccessFlags  uint16
	ThisClass    uint16
	SuperClass   uint16
	Interfaces   []uint16
	Fields       []FieldInfo
	Methods      []MethodInfo
	Attributes   []AttributeInfo
}

func ParseFrom(b []uint8) (*ClassFile, error) {
	scn := BinScanner{b}
	magic := scn.Uint32()
	if magic != 0xCAFEBABE {
		return nil, errors.New("invalid magic header value")
	}

	cls := new(ClassFile)

	cls.MinorVersion = scn.Uint16()
	cls.MajorVersion = scn.Uint16()

	constantCount := scn.Uint16()
	cls.ConstantPool = make([]CpInfo, constantCount)
	for i := range cls.ConstantPool {
		con, err := parseConstant(&scn)
		if err != nil {
			return nil, errors.Wrap(err, "failed to parse class constant pool")
		}
		cls.ConstantPool[i] = con
	}

	cls.AccessFlags = scn.Uint16()
	cls.ThisClass = scn.Uint16()
	cls.SuperClass = scn.Uint16()

	interfaceCount := scn.Uint16()
	cls.Interfaces = make([]uint16, interfaceCount)
	for i := range cls.Interfaces {
		cls.Interfaces[i] = scn.Uint16()
	}

	fieldCount := scn.Uint16()
	cls.Fields = make([]FieldInfo, fieldCount)
	for i := range cls.Fields {
		field, err := parseField(&scn)
		if err != nil {
			return nil, errors.Wrap(err, "failed to parse class field info")
		}
		cls.Fields[i] = field
	}

	methodCount := scn.Uint16()
	cls.Methods = make([]MethodInfo, methodCount)
	for i := range cls.Methods {
		method, err := parseMethod(&scn)
		if err != nil {
			return nil, errors.Wrap(err, "failed to parse class method info")
		}
		cls.Methods[i] = method
	}

	attributes, err := parseAttributes(&scn)
	if err != nil {
		return nil, errors.Wrap(err, "failed to parse class attributes")
	}
	cls.Attributes = attributes

	return cls, nil
}

type AccessFlags uint16

const (
	AccPublic       = 0x0001 // Declared public; may be accessed from outside its package.
	AccPrivate      = 0x0002 // Declared private; usable only within the defining class.
	AccProtected    = 0x0004 // Declared protected; may be accessed within subclasses.
	AccStatic       = 0x0008 // Declared static.
	AccFinal        = 0x0010 // Declared final; never directly assigned to after object construction (JLS ยง17.5).
	AccSynchronized = 0x0020 // Declared synchronized; invocation is wrapped by a monitor use.
	AccVolatile     = 0x0040 // Declared volatile; cannot be cached.
	AccBridge       = 0x0040 // A bridge method, generated by the compiler.
	AccTransient    = 0x0080 // Declared transient; not written or read by a persistent object manager.
	AccVarargs      = 0x0080 // Declared with variable number of arguments.
	AccNative       = 0x0100 // Declared native; implemented in a language other than Java.
	AccAbstract     = 0x0400 // Declared abstract; no implementation is provided.
	AccStrict       = 0x0800 // Declared strictfp; floating-point mode is FP-strict.
	AccSynthetic    = 0x1000 // Declared synthetic; not present in the source code.
	AccEnum         = 0x4000 // Declared as an element of an enum.
)

type FieldInfo struct {
	AccessFlags     AccessFlags
	NameIndex       uint16 // ConstantUtf8Info
	DescriptorIndex uint16 // ConstantUtf8Info
	Attributes      []AttributeInfo
}

func parseField(scn *BinScanner) (info FieldInfo, err error) {
	info.AccessFlags = AccessFlags(scn.Uint16())
	info.NameIndex = scn.Uint16()
	info.DescriptorIndex = scn.Uint16()

	attributes, err := parseAttributes(scn)
	if err != nil {
		return info, errors.Wrap(err, "failed to parse field attributes")
	}
	info.Attributes = attributes

	return info, nil
}

type MethodInfo struct {
	AccessFlags     AccessFlags
	NameIndex       uint16 // ConstantUtf8Info
	DescriptorIndex uint16 // ConstantUtf8Info
	Attributes      []AttributeInfo
}

func parseMethod(scn *BinScanner) (info MethodInfo, err error) {
	info.AccessFlags = AccessFlags(scn.Uint16())
	info.NameIndex = scn.Uint16()
	info.DescriptorIndex = scn.Uint16()

	attributes, err := parseAttributes(scn)
	if err != nil {
		return info, errors.Wrap(err, "failed to parse method attributes")
	}
	info.Attributes = attributes

	return info, nil
}

type AttributeInfo struct {
	AttributeNameIndex uint16 // ConstantUtf8Info
	Info               []uint8
}

func parseAttribute(scn *BinScanner) (info AttributeInfo, err error) {
	info.AttributeNameIndex = scn.Uint16()
	attributeLength := scn.Uint32()
	info.Info = scn.Bytes(int(attributeLength))
	return info, nil
}

func parseAttributes(scn *BinScanner) ([]AttributeInfo, error) {
	attributeCount := scn.Uint16()
	attributes := make([]AttributeInfo, attributeCount)
	for i := range attributes {
		attribute, err := parseAttribute(scn)
		if err != nil {
			return nil, err
		}
		attributes[i] = attribute
	}
	return attributes, nil
}
